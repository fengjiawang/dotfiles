import Cocoa
import SwiftUI

final class SettingsViewController: NSViewController {
    private let viewModel: SettingsViewModel

    init(viewModel: SettingsViewModel) {
        self.viewModel = viewModel
        super.init(nibName: nil, bundle: nil)
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    override func loadView() {
        view = NSView(frame: NSRect(x: 0, y: 0, width: 320, height: 280))
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        setupKeyboardMonitor()
    }

    private func setupUI() {
        let hostingController = NSHostingController(rootView: SettingsView(viewModel: viewModel))
        addChild(hostingController)
        hostingController.view.translatesAutoresizingMaskIntoConstraints = false

        view.addSubview(hostingController.view)

        NSLayoutConstraint.activate([
            hostingController.view.topAnchor.constraint(equalTo: view.topAnchor),
            hostingController.view.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            hostingController.view.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            hostingController.view.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])
    }

    private func setupKeyboardMonitor() {
        NSEvent.addLocalMonitorForEvents(matching: .keyDown) { [weak self] event in
            guard let self = self, self.viewModel.isRecordingHotKey else {
                return event
            }

            self.viewModel.completeRecordingHotKey(with: event)
            return nil
        }
    }
}

struct SettingsView: View {
    @ObservedObject var viewModel: SettingsViewModel

    var body: some View {
        VStack(spacing: 0) {
            VStack(alignment: .leading, spacing: 16) {
                Text("WindowSnap Settings")
                    .font(.headline)

                Divider()

                VStack(alignment: .leading, spacing: 12) {
                    Text("Window Scale")
                        .font(.subheadline)
                        .foregroundColor(.secondary)

                    HStack {
                        Text("Width:")
                            .frame(width: 60, alignment: .leading)
                        PercentageSlider(
                            value: $viewModel.widthPercentage,
                            range: 10...100
                        )
                        Text("\(viewModel.widthPercentage)%")
                            .frame(width: 50)
                            .font(.system(.body, design: .monospaced))
                    }

                    HStack {
                        Text("Height:")
                            .frame(width: 60, alignment: .leading)
                        PercentageSlider(
                            value: $viewModel.heightPercentage,
                            range: 10...100
                        )
                        Text("\(viewModel.heightPercentage)%")
                            .frame(width: 50)
                            .font(.system(.body, design: .monospaced))
                    }
                }

                Divider()

                VStack(alignment: .leading, spacing: 8) {
                    Text("Hotkey")
                        .font(.subheadline)
                        .foregroundColor(.secondary)

                    HotKeyButton(
                        displayString: viewModel.hotKey.displayString,
                        isRecording: viewModel.isRecordingHotKey,
                        onClick: {
                            viewModel.startRecordingHotKey()
                        }
                    )

                    if let error = viewModel.hotKeyConflictError {
                        Text(error)
                            .font(.caption)
                            .foregroundColor(.red)
                    }
                }
            }
            .padding()

            Spacer()

            HStack {
                Button("Reset to Defaults") {
                    viewModel.resetToDefaults()
                }
                .buttonStyle(.bordered)

                Spacer()

                Button("Close") {
                    viewModel.onClose?()
                }
                .buttonStyle(.borderedProminent)
                .keyboardShortcut(.escape)
            }
            .padding()
            .background(Color(NSColor.windowBackgroundColor))
        }
        .frame(width: 320, height: 280)
    }
}

struct PercentageSlider: View {
    @Binding var value: Int
    let range: ClosedRange<Int>

    var body: some View {
        Slider(value: Binding(
            get: { Double(value) },
            set: { value = Int($0) }
        ), in: Double(range.lowerBound)...Double(range.upperBound))
        .onChange(of: value) { newValue in
            let clamped = max(range.lowerBound, min(range.upperBound, newValue))
            if clamped != newValue {
                value = clamped
            }
        }
    }
}

struct HotKeyButton: View {
    let displayString: String
    let isRecording: Bool
    let onClick: () -> Void

    var body: some View {
        Button(action: onClick) {
            HStack {
                Text(isRecording ? "Press any key..." : displayString)
                    .font(.system(.body, design: .monospaced))
                    .frame(maxWidth: .infinity, alignment: .leading)

                if isRecording {
                    Circle()
                        .fill(Color.red)
                        .frame(width: 8, height: 8)
                }
            }
            .padding(8)
            .background(isRecording ? Color.red.opacity(0.1) : Color(NSColor.textBackgroundColor))
            .cornerRadius(6)
            .overlay(
                RoundedRectangle(cornerRadius: 6)
                    .stroke(isRecording ? Color.red : Color.gray.opacity(0.3), lineWidth: isRecording ? 2 : 1)
            )
        }
        .buttonStyle(.plain)
    }
}
