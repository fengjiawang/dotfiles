import Foundation
import AppKit
import Accessibility

enum WindowManagerError: Error, LocalizedError {
    case noActiveWindow
    case windowInFullscreen
    case failedToGetWindowInfo
    case failedToSetPosition
    case failedToSetSize
    case accessibilityPermissionRequired

    var errorDescription: String? {
        switch self {
        case .noActiveWindow:
            return "No active window found"
        case .windowInFullscreen:
            return "Window is in fullscreen mode"
        case .failedToGetWindowInfo:
            return "Failed to get window information"
        case .failedToSetPosition:
            return "Failed to set window position"
        case .failedToSetSize:
            return "Failed to set window size"
        case .accessibilityPermissionRequired:
            return "Accessibility permission is required"
        }
    }
}

final class WindowManager {
    static let shared = WindowManager()

    private let kAXPositionAttribute: CFString = "AXPosition" as CFString
    private let kAXSizeAttribute: CFString = "AXSize" as CFString
    private let kAXFullscreenAttribute: CFString = "AXFullscreen" as CFString
    private let kAXFocusedWindowAttribute: CFString = "AXFocusedWindow" as CFString

    private init() {}

    func centerAndScaleActiveWindow(
        widthPercentage: Int,
        heightPercentage: Int
    ) throws {
        guard let activeWindow = getActiveWindow() else {
            throw WindowManagerError.noActiveWindow
        }

        guard !isWindowFullscreen(activeWindow) else {
            throw WindowManagerError.windowInFullscreen
        }

        guard let screen = getScreenForWindow(activeWindow) else {
            throw WindowManagerError.failedToGetWindowInfo
        }

        let screenFrame = screen.frame
        let targetWidth = screenFrame.width * CGFloat(widthPercentage) / 100.0
        let targetHeight = screenFrame.height * CGFloat(heightPercentage) / 100.0

        let targetX = screenFrame.midX - targetWidth / 2
        let targetY = screenFrame.midY - targetHeight / 2

        let targetPosition = CGPoint(x: targetX, y: targetY)
        let targetSize = CGSize(width: targetWidth, height: targetHeight)

        try setWindowPosition(activeWindow, position: targetPosition)
        try setWindowSize(activeWindow, size: targetSize)
    }

    private func getActiveWindow() -> AXUIElement? {
        let options: CGWindowListOption = [.optionOnScreenOnly, .excludeDesktopElements]
        guard let windowList = CGWindowListCopyWindowInfo(options, kCGNullWindowID) as? [[String: Any]] else {
            return nil
        }

        for windowInfo in windowList {
            if let windowLayer = windowInfo[kCGWindowLayer as String] as? Int,
               windowLayer == 0,
               let windowNumber = windowInfo[kCGWindowNumber as String] as? UInt32 {
                guard let pid = getPIDForWindowNumber(windowNumber) else { continue }
                let axElement = AXUIElementCreateApplication(pid)
                var focusedWindow: CFTypeRef?
                let error = AXUIElementCopyAttributeValue(
                    axElement,
                    kAXFocusedWindowAttribute,
                    &focusedWindow
                )
                if error == AXError.success, focusedWindow != nil {
                    return unsafeBitCast(focusedWindow!, to: AXUIElement.self)
                }
            }
        }

        return nil
    }

    private func getPIDForWindowNumber(_ windowNumber: UInt32) -> pid_t? {
        let options: CGWindowListOption = .optionOnScreenOnly
        guard let list = CGWindowListCopyWindowInfo(options, kCGNullWindowID) as? [[String: Any]] else {
            return nil
        }
        for window in list {
            if let number = window[kCGWindowNumber as String] as? UInt32, number == windowNumber {
                return window[kCGWindowOwnerPID as String] as? pid_t
            }
        }
        return nil
    }

    private func isWindowFullscreen(_ window: AXUIElement) -> Bool {
        var value: CFTypeRef?
        let error = AXUIElementCopyAttributeValue(
            window,
            kAXFullscreenAttribute,
            &value
        )

        if error == AXError.success, let fullscreen = value as? Bool {
            return fullscreen
        }

        return false
    }

    private func getScreenForWindow(_ window: AXUIElement) -> NSScreen? {
        var positionValue: CFTypeRef?
        var sizeValue: CFTypeRef?

        AXUIElementCopyAttributeValue(window, kAXPositionAttribute, &positionValue)
        AXUIElementCopyAttributeValue(window, kAXSizeAttribute, &sizeValue)

        guard let posDict = positionValue as? [String: Any],
              let sizeDict = sizeValue as? [String: Any] else {
            return NSScreen.main
        }

        let position = CGPoint(
            x: (posDict["X"] as? CGFloat) ?? 0,
            y: (posDict["Y"] as? CGFloat) ?? 0
        )
        let size = CGSize(
            width: (sizeDict["W"] as? CGFloat) ?? 0,
            height: (sizeDict["H"] as? CGFloat) ?? 0
        )

        let windowFrame = CGRect(x: position.x, y: position.y, width: size.width, height: size.height)

        for screen in NSScreen.screens {
            if screen.frame.intersects(windowFrame) {
                return screen
            }
        }

        return NSScreen.main
    }

    private func setWindowPosition(_ window: AXUIElement, position: CGPoint) throws {
        let positionValue = [
            "X": position.x as NSNumber,
            "Y": position.y as NSNumber
        ]

        let error = AXUIElementSetAttributeValue(
            window,
            kAXPositionAttribute,
            positionValue as CFTypeRef
        )

        if error != AXError.success {
            throw WindowManagerError.failedToSetPosition
        }
    }

    private func setWindowSize(_ window: AXUIElement, size: CGSize) throws {
        let sizeValue = [
            "W": size.width as NSNumber,
            "H": size.height as NSNumber
        ]

        let error = AXUIElementSetAttributeValue(
            window,
            kAXSizeAttribute,
            sizeValue as CFTypeRef
        )

        if error != AXError.success {
            throw WindowManagerError.failedToSetSize
        }
    }

    func checkAccessibilityPermission() -> Bool {
        return AXIsProcessTrusted()
    }

    func requestAccessibilityPermission() {
        let options: NSDictionary = [:]
        _ = AXIsProcessTrustedWithOptions(options)
    }
}
