import Foundation
import AppKit
import Carbon
import CoreGraphics
import os.log

// MARK: - 日志系统
private let logger = OSLog(subsystem: "com.windowsnap.app", category: "general")

// MARK: - 应用配置

struct AppConfig: Codable {
    var xPercent: Double
    var yPercent: Double
    var widthPercent: Double
    var heightPercent: Double
    var showMenuBarIcon: Bool
    var hotkeyKeyCode: Int  // 快捷键键码
    var hotkeyModifiers: Int  // 快捷键修饰键

    init(xPercent: Double = 0.25, yPercent: Double = 0.25,
         widthPercent: Double = 0.5, heightPercent: Double = 0.5,
         showMenuBarIcon: Bool = true,
         hotkeyKeyCode: Int = 6,  // Z键
         hotkeyModifiers: Int = 0x180000) {  // Ctrl+Option
        self.xPercent = max(0.0, min(1.0, xPercent))
        self.yPercent = max(0.0, min(1.0, yPercent))
        // 宽高最小10%，避免窗口过小
        self.widthPercent = max(0.1, min(1.0, widthPercent))
        self.heightPercent = max(0.1, min(1.0, heightPercent))
        self.showMenuBarIcon = showMenuBarIcon
        self.hotkeyKeyCode = hotkeyKeyCode
        self.hotkeyModifiers = hotkeyModifiers
    }

    static var `default`: AppConfig {
        return AppConfig()
    }
}

// MARK: - 配置管理器

class ConfigManager {
    static let shared = ConfigManager()

    private let configURL: URL?

    private init() {
        if let appSupportURL = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first {
            let appFolderURL = appSupportURL.appendingPathComponent("WindowSnap")
            // 确保目录存在
            try? FileManager.default.createDirectory(at: appFolderURL, withIntermediateDirectories: true)
            configURL = appFolderURL.appendingPathComponent("config.json")
        } else {
            os_log("无法获取应用支持目录，将使用默认配置", log: logger, type: .error)
            configURL = nil
        }
    }

    func load() -> AppConfig {
        guard let configURL = configURL,
              FileManager.default.fileExists(atPath: configURL.path),
              let data = try? Data(contentsOf: configURL) else {
            return .default
        }

        do {
            let config = try JSONDecoder().decode(AppConfig.self, from: data)
            return config
        } catch {
            os_log("无法加载配置文件: %{public}@，使用默认配置", log: logger, type: .error, error.localizedDescription)
            return .default
        }
    }

    func save(_ config: AppConfig) {
        guard let configURL = configURL else {
            os_log("配置URL为空，无法保存配置", log: logger, type: .error)
            return
        }
        do {
            let data = try JSONEncoder().encode(config)
            try data.write(to: configURL)
        } catch {
            os_log("无法保存配置文件: %{public}@", log: logger, type: .error, error.localizedDescription)
        }
    }
}

// MARK: - 窗口调整功能

class WindowSnap {

    private var config: AppConfig

    init(config: AppConfig = ConfigManager.shared.load()) {
        self.config = config
    }

    func updateConfig(_ newConfig: AppConfig) {
        self.config = newConfig
    }

    // 检查辅助功能权限
    func checkAccessibilityPermission() -> Bool {
        let options: NSDictionary = [kAXTrustedCheckOptionPrompt.takeUnretainedValue() as NSString: true]
        let trusted = AXIsProcessTrustedWithOptions(options)
        return trusted
    }

    // 获取当前活动窗口
    func getActiveWindow() -> AXUIElement? {
        guard let frontmostApp = NSWorkspace.shared.frontmostApplication else {
            os_log("无法获取前台应用", log: logger, type: .error)
            return nil
        }

        os_log("获取应用窗口: %{public}@ (PID: %d)", log: logger, type: .debug, frontmostApp.localizedName ?? "未知应用", frontmostApp.processIdentifier)

        let app = AXUIElementCreateApplication(frontmostApp.processIdentifier)

        var value: AnyObject?
        let result = AXUIElementCopyAttributeValue(app, kAXFocusedWindowAttribute as CFString, &value)

        if result == .success, let window = value {
            // 使用安全类型转换
            let typeID = CFGetTypeID(window)
            if typeID == AXUIElementGetTypeID() {
                os_log("成功获取聚焦窗口", log: logger, type: .debug)
                // 安全转换：先转为 CFTypeRef 再转为 AXUIElement
                let axElement = window as CFTypeRef as! AXUIElement
                return axElement
            } else {
                os_log("警告：聚焦窗口属性值类型不正确", log: logger, type: .error)
                return nil
            }
        }

        // 如果无法获取聚焦窗口，尝试获取主窗口
        let result2 = AXUIElementCopyAttributeValue(app, kAXMainWindowAttribute as CFString, &value)
        if result2 == .success, let window = value {
            let typeID = CFGetTypeID(window)
            if typeID == AXUIElementGetTypeID() {
                os_log("成功获取主窗口", log: logger, type: .debug)
                let axElement = window as CFTypeRef as! AXUIElement
                return axElement
            } else {
                os_log("警告：主窗口属性值类型不正确", log: logger, type: .error)
                return nil
            }
        }

        os_log("未能获取到任何窗口", log: logger, type: .error)
        return nil
    }

    // 获取包含窗口的屏幕（支持多屏幕）
    func getScreenForWindow(_ window: AXUIElement) -> NSScreen? {
        var positionValue: AnyObject?
        let result = AXUIElementCopyAttributeValue(window, kAXPositionAttribute as CFString, &positionValue)

        if result == .success, let value = positionValue {
            var point = CGPoint.zero
            AXValueGetValue(value as! AXValue, .cgPoint, &point)

            // 找到包含该点的屏幕
            for screen in NSScreen.screens {
                if screen.frame.contains(point) {
                    return screen
                }
            }
        }

        // 默认返回主屏幕
        return NSScreen.main
    }

    // 调整窗口位置和大小
    func resizeAndMoveWindow(_ window: AXUIElement) {
        guard let screen = getScreenForWindow(window) else {
            os_log("错误：无法获取屏幕", log: logger, type: .error)
            return
        }

        let screenFrame = screen.visibleFrame  // 使用可见区域，排除Dock和菜单栏
        let screenSize = screenFrame.size

        // 验证屏幕尺寸有效
        guard screenSize.width > 0 && screenSize.height > 0 else {
            os_log("错误：无效的屏幕尺寸", log: logger, type: .error)
            return
        }

        let targetWidth = screenSize.width * CGFloat(config.widthPercent)
        let targetHeight = screenSize.height * CGFloat(config.heightPercent)
        let targetX = screenFrame.origin.x + screenSize.width * CGFloat(config.xPercent)
        let targetY = screenFrame.origin.y + screenSize.height * CGFloat(config.yPercent)

        os_log("调整窗口到位置: (%.1f, %.1f)，大小: (%.1f, %.1f)", log: logger, type: .debug, targetX, targetY, targetWidth, targetHeight)

        // 创建位置和大小值
        var point = CGPoint(x: targetX, y: targetY)
        guard let positionValue = AXValueCreate(.cgPoint, &point) else {
            os_log("错误：无法创建位置值", log: logger, type: .error)
            return
        }

        var size = CGSize(width: targetWidth, height: targetHeight)
        guard let sizeValue = AXValueCreate(.cgSize, &size) else {
            os_log("错误：无法创建大小值", log: logger, type: .error)
            return
        }

        // 设置窗口位置
        let positionResult = AXUIElementSetAttributeValue(window, kAXPositionAttribute as CFString, positionValue)
        if positionResult != .success {
            os_log("错误：无法设置窗口位置 (错误代码: %d)", log: logger, type: .error, positionResult.rawValue)
        }

        // 设置窗口大小
        let sizeResult = AXUIElementSetAttributeValue(window, kAXSizeAttribute as CFString, sizeValue)
        if sizeResult != .success {
            os_log("错误：无法设置窗口大小 (错误代码: %d)", log: logger, type: .error, sizeResult.rawValue)
        }
    }

    // 执行调整
    func snapActiveWindow() {
        guard checkAccessibilityPermission() else {
            os_log("辅助功能权限未授予", log: logger, type: .error)
            return
        }

        guard let window = getActiveWindow() else {
            os_log("无法获取当前活动窗口", log: logger, type: .error)
            return
        }

        resizeAndMoveWindow(window)
    }
}

// 全局快捷键监听器
class HotkeyListener {
    private var windowSnap: WindowSnap
    private var eventTap: CFMachPort?
    private var runLoopSource: CFRunLoopSource?
    private var config: AppConfig

    init(windowSnap: WindowSnap, config: AppConfig) {
        self.windowSnap = windowSnap
        self.config = config
    }

    deinit {
        stop()
    }

    func stop() {
        if let source = runLoopSource {
            CFRunLoopRemoveSource(CFRunLoopGetCurrent(), source, .commonModes)
            runLoopSource = nil
        }
        if let tap = eventTap {
            CGEvent.tapEnable(tap: tap, enable: false)
            CFMachPortInvalidate(tap)
            eventTap = nil
        }
    }

    func updateConfig(_ newConfig: AppConfig) {
        self.config = newConfig
    }

    // 事件回调
    private let eventCallback: CGEventTapCallBack = { (proxy, type, event, refcon) -> Unmanaged<CGEvent>? in
        guard let refcon = refcon else {
            return Unmanaged.passUnretained(event)
        }
        let listener = Unmanaged<HotkeyListener>.fromOpaque(refcon).takeUnretainedValue()
        if listener.handleEvent(event: event) {
            return nil // 消费事件，阻止传递给其他应用
        }
        return Unmanaged.passUnretained(event) // 传递事件（不增加引用计数）
    }

    private func handleEvent(event: CGEvent) -> Bool {
        // 检查是否为键盘事件
        guard event.type == .keyDown else { return false }

        // 获取键码
        let keyCode = event.getIntegerValueField(.keyboardEventKeycode)
        guard keyCode == config.hotkeyKeyCode else { return false }

        // 获取修饰键标志
        let flags = event.flags.rawValue

        // 检查 Control 和 Option 键
        let controlPressed = (flags & CGEventFlags.maskControl.rawValue) != 0
        let optionPressed = (flags & CGEventFlags.maskAlternate.rawValue) != 0

        if controlPressed && optionPressed {
            // 使用 weak self 避免循环引用
            DispatchQueue.main.async { [weak self] in
                self?.windowSnap.snapActiveWindow()
            }
            return true
        }

        return false
    }

    func start() {
        // 检查辅助功能权限（事件监听也需要）
        guard windowSnap.checkAccessibilityPermission() else {
            os_log("请授予辅助功能权限以监听全局快捷键", log: logger, type: .error)
            return
        }

        // 创建事件监听
        let eventMask = (1 << CGEventType.keyDown.rawValue)
        guard let tap = CGEvent.tapCreate(
            tap: .cghidEventTap,
            place: .headInsertEventTap,
            options: .defaultTap,
            eventsOfInterest: CGEventMask(eventMask),
            callback: eventCallback,
            userInfo: Unmanaged.passUnretained(self).toOpaque()
        ) else {
            os_log("无法创建事件监听。请检查权限", log: logger, type: .error)
            return
        }

        eventTap = tap

        // 创建并保存运行循环源
        if let source = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, tap, 0) {
            runLoopSource = source
            CFRunLoopAddSource(CFRunLoopGetCurrent(), source, .commonModes)
        }

        // 启用事件监听
        CGEvent.tapEnable(tap: tap, enable: true)

        os_log("快捷键监听已启动", log: logger, type: .info)
    }
}

// MARK: - 应用委托

@available(macOS 10.13, *)
class AppDelegate: NSObject, NSApplicationDelegate {
    private var hotkeyListener: HotkeyListener?
    private var statusItem: NSStatusItem?
    private var settingsWindow: NSWindow?
    private var windowSnap: WindowSnap?

    // 设置窗口UI元素实例变量
    private var xLabel: NSTextField?
    private var xSlider: NSSlider?
    private var yLabel: NSTextField?
    private var ySlider: NSSlider?
    private var widthLabel: NSTextField?
    private var widthSlider: NSSlider?
    private var heightLabel: NSTextField?
    private var heightSlider: NSSlider?
    private var menuBarCheckbox: NSButton?

    private var config: AppConfig {
        didSet {
            updateMenuBarIcon()
            windowSnap?.updateConfig(config)
        }
    }

    override init() {
        self.config = ConfigManager.shared.load()
        super.init()
    }

    func applicationDidFinishLaunching(_ notification: Notification) {
        // 初始化窗口调整器
        windowSnap = WindowSnap(config: config)

        // 初始化快捷键监听器，共享同一个windowSnap实例
        guard let windowSnapInstance = windowSnap else {
            os_log("windowSnap 实例未初始化，应用将在没有快捷键的情况下运行", log: logger, type: .error)
            setupApplicationMenu()
            updateMenuBarIcon()
            return
        }
        hotkeyListener = HotkeyListener(windowSnap: windowSnapInstance, config: config)
        hotkeyListener?.start()

        // 设置应用菜单
        setupApplicationMenu()

        // 更新菜单栏图标
        updateMenuBarIcon()

        os_log("WindowSnap 已启动", log: logger, type: .info)
    }

    private func setupApplicationMenu() {
        let mainMenu = NSMenu()

        // 应用菜单（WindowSnap）
        let appMenuItem = NSMenuItem()
        appMenuItem.submenu = NSMenu()

        // 关于
        let aboutItem = NSMenuItem(title: "关于 WindowSnap", action: #selector(showAbout), keyEquivalent: "")
        appMenuItem.submenu?.addItem(aboutItem)
        appMenuItem.submenu?.addItem(NSMenuItem.separator())

        // 设置 (Cmd+,)
        let preferencesItem = NSMenuItem(title: "设置...", action: #selector(showSettings), keyEquivalent: ",")
        preferencesItem.keyEquivalentModifierMask = [.command]
        appMenuItem.submenu?.addItem(preferencesItem)
        appMenuItem.submenu?.addItem(NSMenuItem.separator())

        // 服务菜单
        let servicesItem = NSMenuItem(title: "服务", action: nil, keyEquivalent: "")
        let servicesMenu = NSMenu()
        servicesItem.submenu = servicesMenu
        appMenuItem.submenu?.addItem(servicesItem)
        NSApp.servicesMenu = servicesMenu

        appMenuItem.submenu?.addItem(NSMenuItem.separator())

        // 隐藏应用 (Cmd+H)
        let hideItem = NSMenuItem(title: "隐藏 WindowSnap", action: #selector(NSApplication.hide(_:)), keyEquivalent: "h")
        hideItem.keyEquivalentModifierMask = [.command]
        appMenuItem.submenu?.addItem(hideItem)

        // 隐藏其他应用 (Cmd+Option+H)
        let hideOthersItem = NSMenuItem(title: "隐藏其他", action: #selector(NSApplication.hideOtherApplications(_:)), keyEquivalent: "h")
        hideOthersItem.keyEquivalentModifierMask = [.command, .option]
        appMenuItem.submenu?.addItem(hideOthersItem)

        // 显示全部
        let showAllItem = NSMenuItem(title: "显示全部", action: #selector(NSApplication.unhideAllApplications(_:)), keyEquivalent: "")
        appMenuItem.submenu?.addItem(showAllItem)
        appMenuItem.submenu?.addItem(NSMenuItem.separator())

        // 退出 (Cmd+Q)
        let quitItem = NSMenuItem(title: "退出 WindowSnap", action: #selector(quitApp), keyEquivalent: "q")
        quitItem.keyEquivalentModifierMask = [.command]
        appMenuItem.submenu?.addItem(quitItem)

        mainMenu.addItem(appMenuItem)

        // 编辑菜单
        let editMenuItem = NSMenuItem()
        editMenuItem.submenu = NSMenu(title: "编辑")

        let undoItem = NSMenuItem(title: "撤销", action: #selector(UndoManager.undo), keyEquivalent: "z")
        undoItem.keyEquivalentModifierMask = [.command]
        editMenuItem.submenu?.addItem(undoItem)

        let redoItem = NSMenuItem(title: "重做", action: #selector(UndoManager.redo), keyEquivalent: "Z")
        redoItem.keyEquivalentModifierMask = [.command, .shift]
        editMenuItem.submenu?.addItem(redoItem)

        editMenuItem.submenu?.addItem(NSMenuItem.separator())

        let cutItem = NSMenuItem(title: "剪切", action: #selector(NSText.cut(_:)), keyEquivalent: "x")
        cutItem.keyEquivalentModifierMask = [.command]
        editMenuItem.submenu?.addItem(cutItem)

        let copyItem = NSMenuItem(title: "复制", action: #selector(NSText.copy(_:)), keyEquivalent: "c")
        copyItem.keyEquivalentModifierMask = [.command]
        editMenuItem.submenu?.addItem(copyItem)

        let pasteItem = NSMenuItem(title: "粘贴", action: #selector(NSText.paste(_:)), keyEquivalent: "v")
        pasteItem.keyEquivalentModifierMask = [.command]
        editMenuItem.submenu?.addItem(pasteItem)

        let selectAllItem = NSMenuItem(title: "全选", action: #selector(NSText.selectAll(_:)), keyEquivalent: "a")
        selectAllItem.keyEquivalentModifierMask = [.command]
        editMenuItem.submenu?.addItem(selectAllItem)

        mainMenu.addItem(editMenuItem)

        // 窗口菜单
        let windowMenuItem = NSMenuItem()
        windowMenuItem.submenu = NSMenu(title: "窗口")

        let minimizeItem = NSMenuItem(title: "最小化", action: #selector(NSWindow.miniaturize(_:)), keyEquivalent: "m")
        minimizeItem.keyEquivalentModifierMask = [.command]
        windowMenuItem.submenu?.addItem(minimizeItem)

        let zoomItem = NSMenuItem(title: "缩放", action: #selector(NSWindow.performZoom(_:)), keyEquivalent: "")
        windowMenuItem.submenu?.addItem(zoomItem)

        windowMenuItem.submenu?.addItem(NSMenuItem.separator())

        let bringAllToFrontItem = NSMenuItem(title: "全部前置", action: #selector(NSApplication.arrangeInFront(_:)), keyEquivalent: "")
        windowMenuItem.submenu?.addItem(bringAllToFrontItem)

        // 设置为窗口菜单
        NSApp.windowsMenu = windowMenuItem.submenu

        mainMenu.addItem(windowMenuItem)

        // 设置主菜单
        NSApp.mainMenu = mainMenu
    }

    private func updateMenuBarIcon() {
        os_log("更新菜单栏图标，显示图标: %{public}@", log: logger, type: .debug, config.showMenuBarIcon ? "是" : "否")

        if config.showMenuBarIcon {
            setupMenuBarIcon()
        } else {
            removeMenuBarIcon()
        }
    }

    private func setupMenuBarIcon() {
        if statusItem == nil {
            statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)

            guard let statusItem = statusItem else {
                os_log("错误：无法创建状态项", log: logger, type: .error)
                return
            }

            if let button = statusItem.button {
                if #available(macOS 11.0, *) {
                    button.image = NSImage(systemSymbolName: "rectangle.inset.filled", accessibilityDescription: "WindowSnap")
                } else {
                    let image = NSImage(size: NSSize(width: 20, height: 20))
                    image.lockFocus()

                    NSColor.white.set()
                    let outerRect = NSRect(x: 2, y: 2, width: 16, height: 16)
                    let outerPath = NSBezierPath(roundedRect: outerRect, xRadius: 4, yRadius: 4)
                    outerPath.lineWidth = 1.5
                    outerPath.stroke()

                    NSColor.systemGray.set()
                    let innerRect = NSRect(x: 5, y: 5, width: 10, height: 10)
                    let innerPath = NSBezierPath(roundedRect: innerRect, xRadius: 2, yRadius: 2)
                    innerPath.fill()

                    image.unlockFocus()
                    image.isTemplate = true
                    button.image = image
                }
                button.image?.isTemplate = true
            }

            // 创建菜单
            let menu = NSMenu()

            menu.addItem(NSMenuItem(title: "调整当前窗口 (Ctrl+Option+Z)", action: #selector(snapCurrentWindow), keyEquivalent: ""))
            menu.addItem(NSMenuItem.separator())

            let settingsItem = NSMenuItem(title: "设置", action: #selector(showSettings), keyEquivalent: ",")
            settingsItem.keyEquivalentModifierMask = [.command]
            menu.addItem(settingsItem)

            menu.addItem(NSMenuItem(title: "关于", action: #selector(showAbout), keyEquivalent: ""))
            menu.addItem(NSMenuItem.separator())

            let quitItem = NSMenuItem(title: "退出", action: #selector(quitApp), keyEquivalent: "q")
            quitItem.keyEquivalentModifierMask = [.command]
            menu.addItem(quitItem)

            statusItem.menu = menu
        }
    }

    private func removeMenuBarIcon() {
        if let statusItem = statusItem {
            NSStatusBar.system.removeStatusItem(statusItem)
            self.statusItem = nil
        }
    }

    @objc private func snapCurrentWindow() {
        windowSnap?.snapActiveWindow()
    }

    @objc private func showSettings() {
        if settingsWindow == nil {
            createSettingsWindow()
        }

        settingsWindow?.makeKeyAndOrderFront(nil)
        NSApp.activate(ignoringOtherApps: true)
    }

    @objc private func showAbout() {
        let alert = NSAlert()
        alert.messageText = "WindowSnap"
        alert.informativeText = "一个 macOS 窗口管理工具\n快捷键: Ctrl+Option+Z\n版本: 1.0"
        alert.alertStyle = .informational
        alert.addButton(withTitle: "确定")
        alert.runModal()
    }

    @objc private func quitApp() {
        NSApp.terminate(nil)
    }

    // 更新所有标签文本
    private func updateLabels() {
        xLabel?.stringValue = "横坐标百分比 (\(Int(config.xPercent * 100))%):"
        yLabel?.stringValue = "纵坐标百分比 (\(Int(config.yPercent * 100))%):"
        widthLabel?.stringValue = "宽度百分比 (\(Int(config.widthPercent * 100))%):"
        heightLabel?.stringValue = "高度百分比 (\(Int(config.heightPercent * 100))%):"
    }

    // 清理设置窗口UI元素引用
    private func cleanupSettingUIElements() {
        // 移除滑块的目标-动作绑定，防止回调访问已释放的标签
        xSlider?.target = nil
        ySlider?.target = nil
        widthSlider?.target = nil
        heightSlider?.target = nil
        menuBarCheckbox?.target = nil

        // 清空引用
        xLabel = nil
        xSlider = nil
        yLabel = nil
        ySlider = nil
        widthLabel = nil
        widthSlider = nil
        heightLabel = nil
        heightSlider = nil
        menuBarCheckbox = nil
    }

    private func createSettingsWindow() {
        let window = NSWindow(
            contentRect: NSRect(x: 0, y: 0, width: 400, height: 300),
            styleMask: [.titled, .closable],
            backing: .buffered,
            defer: false
        )

        window.title = "WindowSnap 设置"
        window.center()

        let contentView = NSView(frame: NSRect(x: 0, y: 0, width: 400, height: 300))

        // 创建标签和滑块，赋值给实例变量
        xLabel = NSTextField(labelWithString: "横坐标百分比 (\(Int(config.xPercent * 100))%):")
        xLabel?.frame = NSRect(x: 20, y: 250, width: 150, height: 20)

        xSlider = NSSlider(value: config.xPercent * 100, minValue: 0, maxValue: 100, target: self, action: #selector(xSliderChanged(_:)))
        xSlider?.frame = NSRect(x: 180, y: 250, width: 200, height: 20)

        yLabel = NSTextField(labelWithString: "纵坐标百分比 (\(Int(config.yPercent * 100))%):")
        yLabel?.frame = NSRect(x: 20, y: 220, width: 150, height: 20)

        ySlider = NSSlider(value: config.yPercent * 100, minValue: 0, maxValue: 100, target: self, action: #selector(ySliderChanged(_:)))
        ySlider?.frame = NSRect(x: 180, y: 220, width: 200, height: 20)

        widthLabel = NSTextField(labelWithString: "宽度百分比 (\(Int(config.widthPercent * 100))%):")
        widthLabel?.frame = NSRect(x: 20, y: 190, width: 150, height: 20)

        widthSlider = NSSlider(value: config.widthPercent * 100, minValue: 0, maxValue: 100, target: self, action: #selector(widthSliderChanged(_:)))
        widthSlider?.frame = NSRect(x: 180, y: 190, width: 200, height: 20)

        heightLabel = NSTextField(labelWithString: "高度百分比 (\(Int(config.heightPercent * 100))%):")
        heightLabel?.frame = NSRect(x: 20, y: 160, width: 150, height: 20)

        heightSlider = NSSlider(value: config.heightPercent * 100, minValue: 0, maxValue: 100, target: self, action: #selector(heightSliderChanged(_:)))
        heightSlider?.frame = NSRect(x: 180, y: 160, width: 200, height: 20)

        // 菜单栏图标选项
        menuBarCheckbox = NSButton(checkboxWithTitle: "显示菜单栏图标", target: self, action: #selector(menuBarCheckboxChanged(_:)))
        menuBarCheckbox?.frame = NSRect(x: 20, y: 120, width: 200, height: 20)
        menuBarCheckbox?.state = config.showMenuBarIcon ? .on : .off

        // 保存按钮
        let saveButton = NSButton(title: "保存", target: self, action: #selector(saveSettings))
        saveButton.frame = NSRect(x: 280, y: 20, width: 100, height: 30)

        // 添加子视图
        if let xLabel = xLabel { contentView.addSubview(xLabel) }
        if let xSlider = xSlider { contentView.addSubview(xSlider) }
        if let yLabel = yLabel { contentView.addSubview(yLabel) }
        if let ySlider = ySlider { contentView.addSubview(ySlider) }
        if let widthLabel = widthLabel { contentView.addSubview(widthLabel) }
        if let widthSlider = widthSlider { contentView.addSubview(widthSlider) }
        if let heightLabel = heightLabel { contentView.addSubview(heightLabel) }
        if let heightSlider = heightSlider { contentView.addSubview(heightSlider) }
        if let menuBarCheckbox = menuBarCheckbox { contentView.addSubview(menuBarCheckbox) }
        contentView.addSubview(saveButton)

        window.contentView = contentView
        settingsWindow = window

        // 设置窗口委托
        window.delegate = self

        // 确保标签文本与当前配置一致
        updateLabels()
    }

    @objc private func xSliderChanged(_ sender: NSSlider) {
        config.xPercent = sender.doubleValue / 100.0
        updateLabels()
    }

    @objc private func ySliderChanged(_ sender: NSSlider) {
        config.yPercent = sender.doubleValue / 100.0
        updateLabels()
    }

    @objc private func widthSliderChanged(_ sender: NSSlider) {
        config.widthPercent = sender.doubleValue / 100.0
        updateLabels()
    }

    @objc private func heightSliderChanged(_ sender: NSSlider) {
        config.heightPercent = sender.doubleValue / 100.0
        updateLabels()
    }

    @objc private func menuBarCheckboxChanged(_ sender: NSButton) {
        config.showMenuBarIcon = sender.state == .on
    }

    @objc private func saveSettings() {
        // 验证windowSnap实例存在
        guard let windowSnap = windowSnap else {
            os_log("错误：windowSnap实例为nil，无法更新配置", log: logger, type: .error)
            let alert = NSAlert()
            alert.messageText = "保存失败"
            alert.informativeText = "内部错误：窗口调整器未初始化。请重启应用。"
            alert.alertStyle = .critical
            alert.addButton(withTitle: "确定")
            alert.runModal()
            return
        }

        // 保存配置
        ConfigManager.shared.save(config)

        // 确保windowSnap使用最新配置
        windowSnap.updateConfig(config)
        hotkeyListener?.updateConfig(config)

        // 隐藏设置窗口
        settingsWindow?.orderOut(nil)

        // 清理UI元素引用
        cleanupSettingUIElements()
        self.settingsWindow = nil
    }
}

extension AppDelegate: NSWindowDelegate {
    func windowWillClose(_ notification: Notification) {
        // 确保通知对象是设置窗口
        guard let closingWindow = notification.object as? NSWindow,
              closingWindow == settingsWindow else {
            return
        }

        // 清理UI元素引用
        cleanupSettingUIElements()
        settingsWindow = nil
    }
}

// MARK: - 主入口点

// 旧的主入口点（已弃用）
// let listener = HotkeyListener()
// listener.start()

// 新的主入口点
let app = NSApplication.shared
let delegate = AppDelegate()
app.delegate = delegate
app.run()
