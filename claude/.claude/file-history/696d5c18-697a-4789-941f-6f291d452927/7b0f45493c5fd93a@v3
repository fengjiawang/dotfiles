import Foundation
import AppKit
import Carbon
import CoreGraphics
import os.log

// MARK: - 日志系统
private let logger = OSLog(subsystem: "com.windowsnap.app", category: "general")

// MARK: - 应用配置

struct AppConfig: Codable {
    var xPercent: Double
    var yPercent: Double
    var widthPercent: Double
    var heightPercent: Double
    var showMenuBarIcon: Bool
    var hotkeyKeyCode: Int  // 快捷键键码
    var hotkeyModifiers: Int  // 快捷键修饰键

    init(xPercent: Double = 0.25, yPercent: Double = 0.25,
         widthPercent: Double = 0.5, heightPercent: Double = 0.5,
         showMenuBarIcon: Bool = true,
         hotkeyKeyCode: Int = 6,  // Z键
         hotkeyModifiers: Int = 0x180000) {  // Ctrl+Option
        self.xPercent = max(0.0, min(1.0, xPercent))
        self.yPercent = max(0.0, min(1.0, yPercent))
        // 宽高最小10%，避免窗口过小
        self.widthPercent = max(0.1, min(1.0, widthPercent))
        self.heightPercent = max(0.1, min(1.0, heightPercent))
        self.showMenuBarIcon = showMenuBarIcon
        self.hotkeyKeyCode = hotkeyKeyCode
        self.hotkeyModifiers = hotkeyModifiers
    }

    static var `default`: AppConfig {
        return AppConfig()
    }
}

// MARK: - 配置管理器

class ConfigManager {
    static let shared = ConfigManager()

    private let configURL: URL?

    private init() {
        if let appSupportURL = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first {
            let appFolderURL = appSupportURL.appendingPathComponent("WindowSnap")
            // 确保目录存在
            try? FileManager.default.createDirectory(at: appFolderURL, withIntermediateDirectories: true)
            configURL = appFolderURL.appendingPathComponent("config.json")
        } else {
            os_log("无法获取应用支持目录，将使用默认配置", log: logger, type: .error)
            configURL = nil
        }
    }

    func load() -> AppConfig {
        guard let configURL = configURL,
              FileManager.default.fileExists(atPath: configURL.path),
              let data = try? Data(contentsOf: configURL) else {
            return .default
        }

        do {
            let config = try JSONDecoder().decode(AppConfig.self, from: data)
            return config
        } catch {
            os_log("无法加载配置文件: %{public}@，使用默认配置", log: logger, type: .error, error.localizedDescription)
            return .default
        }
    }

    func save(_ config: AppConfig) {
        guard let configURL = configURL else {
            os_log("配置URL为空，无法保存配置", log: logger, type: .error)
            return
        }
        do {
            let data = try JSONEncoder().encode(config)
            try data.write(to: configURL)
        } catch {
            os_log("无法保存配置文件: %{public}@", log: logger, type: .error, error.localizedDescription)
        }
    }
}

// MARK: - 窗口调整功能

class WindowSnap {

    private var config: AppConfig

    init(config: AppConfig = ConfigManager.shared.load()) {
        self.config = config
    }

    func updateConfig(_ newConfig: AppConfig) {
        self.config = newConfig
    }

    // 检查辅助功能权限
    func checkAccessibilityPermission() -> Bool {
        let options: NSDictionary = [kAXTrustedCheckOptionPrompt.takeUnretainedValue() as NSString: true]
        let trusted = AXIsProcessTrustedWithOptions(options)
        return trusted
    }

    // 获取当前活动窗口
    func getActiveWindow() -> AXUIElement? {
        guard let frontmostApp = NSWorkspace.shared.frontmostApplication else {
            os_log("无法获取前台应用", log: logger, type: .error)
            return nil
        }

        os_log("获取应用窗口: %{public}@ (PID: %d)", log: logger, type: .debug, frontmostApp.localizedName ?? "未知应用", frontmostApp.processIdentifier)

        let app = AXUIElementCreateApplication(frontmostApp.processIdentifier)

        var value: AnyObject?
        let result = AXUIElementCopyAttributeValue(app, kAXFocusedWindowAttribute as CFString, &value)

        if result == .success, let window = value {
            // 使用安全类型转换
            let typeID = CFGetTypeID(window)
            if typeID == AXUIElementGetTypeID() {
                os_log("成功获取聚焦窗口", log: logger, type: .debug)
                // 安全转换：先转为 CFTypeRef 再转为 AXUIElement
                let axElement = window as CFTypeRef as! AXUIElement
                return axElement
            } else {
                os_log("警告：聚焦窗口属性值类型不正确", log: logger, type: .error)
                return nil
            }
        }

        // 如果无法获取聚焦窗口，尝试获取主窗口
        let result2 = AXUIElementCopyAttributeValue(app, kAXMainWindowAttribute as CFString, &value)
        if result2 == .success, let window = value {
            let typeID = CFGetTypeID(window)
            if typeID == AXUIElementGetTypeID() {
                os_log("成功获取主窗口", log: logger, type: .debug)
                let axElement = window as CFTypeRef as! AXUIElement
                return axElement
            } else {
                os_log("警告：主窗口属性值类型不正确", log: logger, type: .error)
                return nil
            }
        }

        os_log("未能获取到任何窗口", log: logger, type: .error)
        return nil
    }

    // 获取包含窗口的屏幕（支持多屏幕）
    func getScreenForWindow(_ window: AXUIElement) -> NSScreen? {
        var positionValue: AnyObject?
        let result = AXUIElementCopyAttributeValue(window, kAXPositionAttribute as CFString, &positionValue)

        if result == .success, let value = positionValue {
            var point = CGPoint.zero
            AXValueGetValue(value as! AXValue, .cgPoint, &point)

            // 找到包含该点的屏幕
            for screen in NSScreen.screens {
                if screen.frame.contains(point) {
                    return screen
                }
            }
        }

        // 默认返回主屏幕
        return NSScreen.main
    }

    // 调整窗口位置和大小
    func resizeAndMoveWindow(_ window: AXUIElement) {
        guard let screen = getScreenForWindow(window) else {
            os_log("错误：无法获取屏幕", log: logger, type: .error)
            return
        }

        let screenFrame = screen.visibleFrame  // 使用可见区域，排除Dock和菜单栏
        let screenSize = screenFrame.size

        // 验证屏幕尺寸有效
        guard screenSize.width > 0 && screenSize.height > 0 else {
            os_log("错误：无效的屏幕尺寸", log: logger, type: .error)
            return
        }

        let targetWidth = screenSize.width * CGFloat(config.widthPercent)
        let targetHeight = screenSize.height * CGFloat(config.heightPercent)
        let targetX = screenFrame.origin.x + screenSize.width * CGFloat(config.xPercent)
        let targetY = screenFrame.origin.y + screenSize.height * CGFloat(config.yPercent)

        os_log("调整窗口到位置: (%.1f, %.1f)，大小: (%.1f, %.1f)", log: logger, type: .debug, targetX, targetY, targetWidth, targetHeight)

        // 创建位置和大小值
        var point = CGPoint(x: targetX, y: targetY)
        guard let positionValue = AXValueCreate(.cgPoint, &point) else {
            os_log("错误：无法创建位置值", log: logger, type: .error)
            return
        }

        var size = CGSize(width: targetWidth, height: targetHeight)
        guard let sizeValue = AXValueCreate(.cgSize, &size) else {
            os_log("错误：无法创建大小值", log: logger, type: .error)
            return
        }

        // 设置窗口位置
        let positionResult = AXUIElementSetAttributeValue(window, kAXPositionAttribute as CFString, positionValue)
        if positionResult != .success {
            os_log("错误：无法设置窗口位置 (错误代码: %d)", log: logger, type: .error, positionResult.rawValue)
        }

        // 设置窗口大小
        let sizeResult = AXUIElementSetAttributeValue(window, kAXSizeAttribute as CFString, sizeValue)
        if sizeResult != .success {
            os_log("错误：无法设置窗口大小 (错误代码: %d)", log: logger, type: .error, sizeResult.rawValue)
        }
    }

    // 执行调整
    func snapActiveWindow() {
        guard checkAccessibilityPermission() else {
            os_log("辅助功能权限未授予", log: logger, type: .error)
            return
        }

        guard let window = getActiveWindow() else {
            os_log("无法获取当前活动窗口", log: logger, type: .error)
            return
        }

        resizeAndMoveWindow(window)
    }
}

// 全局快捷键监听器
class HotkeyListener {
    private var windowSnap: WindowSnap
    private var eventTap: CFMachPort?
    private var runLoopSource: CFRunLoopSource?
    private var config: AppConfig

    init(windowSnap: WindowSnap, config: AppConfig) {
        self.windowSnap = windowSnap
        self.config = config
    }

    deinit {
        stop()
    }

    func stop() {
        if let source = runLoopSource {
            CFRunLoopRemoveSource(CFRunLoopGetCurrent(), source, .commonModes)
            runLoopSource = nil
        }
        if let tap = eventTap {
            CGEvent.tapEnable(tap: tap, enable: false)
            CFMachPortInvalidate(tap)
            eventTap = nil
        }
    }

    func updateConfig(_ newConfig: AppConfig) {
        self.config = newConfig
    }

    // 事件回调
    private let eventCallback: CGEventTapCallBack = { (proxy, type, event, refcon) -> Unmanaged<CGEvent>? in
        guard let refcon = refcon else {
            return Unmanaged.passUnretained(event)
        }
        let listener = Unmanaged<HotkeyListener>.fromOpaque(refcon).takeUnretainedValue()
        if listener.handleEvent(event: event) {
            return nil // 消费事件，阻止传递给其他应用
        }
        return Unmanaged.passUnretained(event) // 传递事件（不增加引用计数）
    }

    private func handleEvent(event: CGEvent) -> Bool {
        // 检查是否为键盘事件
        guard event.type == .keyDown else { return false }

        // 获取键码
        let keyCode = event.getIntegerValueField(.keyboardEventKeycode)
        guard keyCode == config.hotkeyKeyCode else { return false }

        // 获取修饰键标志
        let flags = event.flags.rawValue

        // 检查 Control 和 Option 键
        let controlPressed = (flags & CGEventFlags.maskControl.rawValue) != 0
        let optionPressed = (flags & CGEventFlags.maskAlternate.rawValue) != 0

        if controlPressed && optionPressed {
            // 使用 weak self 避免循环引用
            DispatchQueue.main.async { [weak self] in
                self?.windowSnap.snapActiveWindow()
            }
            return true
        }

        return false
    }

    func start() {
        // 检查辅助功能权限（事件监听也需要）
        guard windowSnap.checkAccessibilityPermission() else {
            os_log("请授予辅助功能权限以监听全局快捷键", log: logger, type: .error)
            return
        }

        // 创建事件监听
        let eventMask = (1 << CGEventType.keyDown.rawValue)
        guard let tap = CGEvent.tapCreate(
            tap: .cghidEventTap,
            place: .headInsertEventTap,
            options: .defaultTap,
            eventsOfInterest: CGEventMask(eventMask),
            callback: eventCallback,
            userInfo: Unmanaged.passUnretained(self).toOpaque()
        ) else {
            os_log("无法创建事件监听。请检查权限", log: logger, type: .error)
            return
        }

        eventTap = tap

        // 创建并保存运行循环源
        if let source = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, tap, 0) {
            runLoopSource = source
            CFRunLoopAddSource(CFRunLoopGetCurrent(), source, .commonModes)
        }

        // 启用事件监听
        CGEvent.tapEnable(tap: tap, enable: true)

        os_log("快捷键监听已启动", log: logger, type: .info)
    }
}

// MARK: - 应用委托

@available(macOS 10.13, *)
class AppDelegate: NSObject, NSApplicationDelegate {
    private var hotkeyListener: HotkeyListener?
    private var statusItem: NSStatusItem?
    private var settingsWindow: NSWindow?
    private var windowSnap: WindowSnap?

    // 设置窗口UI元素实例变量
    private var xLabel: NSTextField?
    private var xSlider: NSSlider?
    private var xTextField: NSTextField?
    private var yLabel: NSTextField?
    private var ySlider: NSSlider?
    private var yTextField: NSTextField?
    private var widthLabel: NSTextField?
    private var widthSlider: NSSlider?
    private var widthTextField: NSTextField?
    private var heightLabel: NSTextField?
    private var heightSlider: NSSlider?
    private var heightTextField: NSTextField?
    private var menuBarCheckbox: NSButton?

    // 快捷键配置UI元素
    private var hotkeyLabel: NSTextField?
    private var hotkeyPopup: NSPopUpButton?
    private var modifierCheckboxes: [NSButton] = []

    private var config: AppConfig {
        didSet {
            updateMenuBarIcon()
            windowSnap?.updateConfig(config)
            updateMenuTitle()
        }
    }

    // 从快捷键UI获取当前的修饰键值
    private var currentHotkeyModifiers: Int {
        var modifiers: Int = 0
        if modifierCheckboxes.count > 0 && modifierCheckboxes[0].state == .on {
            modifiers |= 0x20000  // shift
        }
        if modifierCheckboxes.count > 1 && modifierCheckboxes[1].state == .on {
            modifiers |= 0x40000  // control
        }
        if modifierCheckboxes.count > 2 && modifierCheckboxes[2].state == .on {
            modifiers |= 0x80000  // option
        }
        if modifierCheckboxes.count > 3 && modifierCheckboxes[3].state == .on {
            modifiers |= 0x100000  // command
        }
        return modifiers
    }

    // 从快捷键UI获取当前的键码
    private var currentHotkeyKeyCode: Int {
        guard let popup = hotkeyPopup else { return config.hotkeyKeyCode }
        let selectedTag = popup.selectedTag()
        return selectedTag >= 0 ? selectedTag : config.hotkeyKeyCode
    }

    // 获取当前快捷键描述文本
    private func getHotkeyDescription() -> String {
        var parts: [String] = []

        if modifierCheckboxes.count > 0 && modifierCheckboxes[0].state == .on {
            parts.append("Shift")
        }
        if modifierCheckboxes.count > 1 && modifierCheckboxes[1].state == .on {
            parts.append("Ctrl")
        }
        if modifierCheckboxes.count > 2 && modifierCheckboxes[2].state == .on {
            parts.append("Option")
        }
        if modifierCheckboxes.count > 3 && modifierCheckboxes[3].state == .on {
            parts.append("Cmd")
        }

        if let popup = hotkeyPopup, let keyName = popup.titleOfSelectedItem {
            parts.append(keyName)
        }

        return parts.joined(separator: "+")
    }

    // 更新菜单栏标题
    private func updateMenuTitle() {
        if let menu = statusItem?.menu, let firstItem = menu.items.first {
            let hotkeyText = getHotkeyDescription()
            firstItem.title = "调整当前窗口 (\(hotkeyText))"
        }
    }

    override init() {
        self.config = ConfigManager.shared.load()
        super.init()
    }

    func applicationDidFinishLaunching(_ notification: Notification) {
        // 初始化窗口调整器
        windowSnap = WindowSnap(config: config)

        // 初始化快捷键监听器，共享同一个windowSnap实例
        guard let windowSnapInstance = windowSnap else {
            os_log("windowSnap 实例未初始化，应用将在没有快捷键的情况下运行", log: logger, type: .error)
            setupApplicationMenu()
            updateMenuBarIcon()
            return
        }
        hotkeyListener = HotkeyListener(windowSnap: windowSnapInstance, config: config)
        hotkeyListener?.start()

        // 设置应用菜单
        setupApplicationMenu()

        // 更新菜单栏图标
        updateMenuBarIcon()

        os_log("WindowSnap 已启动", log: logger, type: .info)
    }

    private func setupApplicationMenu() {
        let mainMenu = NSMenu()

        // 应用菜单（WindowSnap）
        let appMenuItem = NSMenuItem()
        appMenuItem.submenu = NSMenu()

        // 关于
        let aboutItem = NSMenuItem(title: "关于 WindowSnap", action: #selector(showAbout), keyEquivalent: "")
        appMenuItem.submenu?.addItem(aboutItem)
        appMenuItem.submenu?.addItem(NSMenuItem.separator())

        // 设置 (Cmd+,)
        let preferencesItem = NSMenuItem(title: "设置...", action: #selector(showSettings), keyEquivalent: ",")
        preferencesItem.keyEquivalentModifierMask = [.command]
        appMenuItem.submenu?.addItem(preferencesItem)
        appMenuItem.submenu?.addItem(NSMenuItem.separator())

        // 服务菜单
        let servicesItem = NSMenuItem(title: "服务", action: nil, keyEquivalent: "")
        let servicesMenu = NSMenu()
        servicesItem.submenu = servicesMenu
        appMenuItem.submenu?.addItem(servicesItem)
        NSApp.servicesMenu = servicesMenu

        appMenuItem.submenu?.addItem(NSMenuItem.separator())

        // 隐藏应用 (Cmd+H)
        let hideItem = NSMenuItem(title: "隐藏 WindowSnap", action: #selector(NSApplication.hide(_:)), keyEquivalent: "h")
        hideItem.keyEquivalentModifierMask = [.command]
        appMenuItem.submenu?.addItem(hideItem)

        // 隐藏其他应用 (Cmd+Option+H)
        let hideOthersItem = NSMenuItem(title: "隐藏其他", action: #selector(NSApplication.hideOtherApplications(_:)), keyEquivalent: "h")
        hideOthersItem.keyEquivalentModifierMask = [.command, .option]
        appMenuItem.submenu?.addItem(hideOthersItem)

        // 显示全部
        let showAllItem = NSMenuItem(title: "显示全部", action: #selector(NSApplication.unhideAllApplications(_:)), keyEquivalent: "")
        appMenuItem.submenu?.addItem(showAllItem)
        appMenuItem.submenu?.addItem(NSMenuItem.separator())

        // 退出 (Cmd+Q)
        let quitItem = NSMenuItem(title: "退出 WindowSnap", action: #selector(quitApp), keyEquivalent: "q")
        quitItem.keyEquivalentModifierMask = [.command]
        appMenuItem.submenu?.addItem(quitItem)

        mainMenu.addItem(appMenuItem)

        // 编辑菜单
        let editMenuItem = NSMenuItem()
        editMenuItem.submenu = NSMenu(title: "编辑")

        let undoItem = NSMenuItem(title: "撤销", action: #selector(UndoManager.undo), keyEquivalent: "z")
        undoItem.keyEquivalentModifierMask = [.command]
        editMenuItem.submenu?.addItem(undoItem)

        let redoItem = NSMenuItem(title: "重做", action: #selector(UndoManager.redo), keyEquivalent: "Z")
        redoItem.keyEquivalentModifierMask = [.command, .shift]
        editMenuItem.submenu?.addItem(redoItem)

        editMenuItem.submenu?.addItem(NSMenuItem.separator())

        let cutItem = NSMenuItem(title: "剪切", action: #selector(NSText.cut(_:)), keyEquivalent: "x")
        cutItem.keyEquivalentModifierMask = [.command]
        editMenuItem.submenu?.addItem(cutItem)

        let copyItem = NSMenuItem(title: "复制", action: #selector(NSText.copy(_:)), keyEquivalent: "c")
        copyItem.keyEquivalentModifierMask = [.command]
        editMenuItem.submenu?.addItem(copyItem)

        let pasteItem = NSMenuItem(title: "粘贴", action: #selector(NSText.paste(_:)), keyEquivalent: "v")
        pasteItem.keyEquivalentModifierMask = [.command]
        editMenuItem.submenu?.addItem(pasteItem)

        let selectAllItem = NSMenuItem(title: "全选", action: #selector(NSText.selectAll(_:)), keyEquivalent: "a")
        selectAllItem.keyEquivalentModifierMask = [.command]
        editMenuItem.submenu?.addItem(selectAllItem)

        mainMenu.addItem(editMenuItem)

        // 窗口菜单
        let windowMenuItem = NSMenuItem()
        windowMenuItem.submenu = NSMenu(title: "窗口")

        let minimizeItem = NSMenuItem(title: "最小化", action: #selector(NSWindow.miniaturize(_:)), keyEquivalent: "m")
        minimizeItem.keyEquivalentModifierMask = [.command]
        windowMenuItem.submenu?.addItem(minimizeItem)

        let zoomItem = NSMenuItem(title: "缩放", action: #selector(NSWindow.performZoom(_:)), keyEquivalent: "")
        windowMenuItem.submenu?.addItem(zoomItem)

        windowMenuItem.submenu?.addItem(NSMenuItem.separator())

        let bringAllToFrontItem = NSMenuItem(title: "全部前置", action: #selector(NSApplication.arrangeInFront(_:)), keyEquivalent: "")
        windowMenuItem.submenu?.addItem(bringAllToFrontItem)

        // 设置为窗口菜单
        NSApp.windowsMenu = windowMenuItem.submenu

        mainMenu.addItem(windowMenuItem)

        // 设置主菜单
        NSApp.mainMenu = mainMenu
    }

    private func updateMenuBarIcon() {
        os_log("更新菜单栏图标，显示图标: %{public}@", log: logger, type: .debug, config.showMenuBarIcon ? "是" : "否")

        if config.showMenuBarIcon {
            setupMenuBarIcon()
        } else {
            removeMenuBarIcon()
        }
    }

    private func setupMenuBarIcon() {
        if statusItem == nil {
            statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)

            guard let statusItem = statusItem else {
                os_log("错误：无法创建状态项", log: logger, type: .error)
                return
            }

            if let button = statusItem.button {
                if #available(macOS 11.0, *) {
                    button.image = NSImage(systemSymbolName: "rectangle.inset.filled", accessibilityDescription: "WindowSnap")
                } else {
                    let image = NSImage(size: NSSize(width: 20, height: 20))
                    image.lockFocus()

                    NSColor.white.set()
                    let outerRect = NSRect(x: 2, y: 2, width: 16, height: 16)
                    let outerPath = NSBezierPath(roundedRect: outerRect, xRadius: 4, yRadius: 4)
                    outerPath.lineWidth = 1.5
                    outerPath.stroke()

                    NSColor.systemGray.set()
                    let innerRect = NSRect(x: 5, y: 5, width: 10, height: 10)
                    let innerPath = NSBezierPath(roundedRect: innerRect, xRadius: 2, yRadius: 2)
                    innerPath.fill()

                    image.unlockFocus()
                    image.isTemplate = true
                    button.image = image
                }
                button.image?.isTemplate = true
            }

            // 创建菜单
            let menu = NSMenu()

            let hotkeyText = getHotkeyDescription()
            menu.addItem(NSMenuItem(title: "调整当前窗口 (\(hotkeyText))", action: #selector(snapCurrentWindow), keyEquivalent: ""))
            menu.addItem(NSMenuItem.separator())

            let settingsItem = NSMenuItem(title: "设置", action: #selector(showSettings), keyEquivalent: ",")
            settingsItem.keyEquivalentModifierMask = [.command]
            menu.addItem(settingsItem)

            menu.addItem(NSMenuItem(title: "关于", action: #selector(showAbout), keyEquivalent: ""))
            menu.addItem(NSMenuItem.separator())

            let quitItem = NSMenuItem(title: "退出", action: #selector(quitApp), keyEquivalent: "q")
            quitItem.keyEquivalentModifierMask = [.command]
            menu.addItem(quitItem)

            statusItem.menu = menu
        }
    }

    private func removeMenuBarIcon() {
        if let statusItem = statusItem {
            NSStatusBar.system.removeStatusItem(statusItem)
            self.statusItem = nil
        }
    }

    @objc private func snapCurrentWindow() {
        windowSnap?.snapActiveWindow()
    }

    @objc private func showSettings() {
        if settingsWindow == nil {
            createSettingsWindow()
        }

        settingsWindow?.makeKeyAndOrderFront(nil)
        NSApp.activate(ignoringOtherApps: true)
    }

    @objc private func showAbout() {
        let alert = NSAlert()
        alert.messageText = "WindowSnap"
        alert.informativeText = "一个 macOS 窗口管理工具\n快捷键: Ctrl+Option+Z\n版本: 1.0"
        alert.alertStyle = .informational
        alert.addButton(withTitle: "确定")
        alert.runModal()
    }

    @objc private func quitApp() {
        NSApp.terminate(nil)
    }

    // 更新所有标签和文本框
    private func updateLabels() {
        xLabel?.stringValue = "横坐标 (%):"
        xTextField?.stringValue = String(format: "%.0f", config.xPercent * 100)
        xSlider?.doubleValue = config.xPercent * 100

        yLabel?.stringValue = "纵坐标 (%):"
        yTextField?.stringValue = String(format: "%.0f", config.yPercent * 100)
        ySlider?.doubleValue = config.yPercent * 100

        widthLabel?.stringValue = "宽度 (%):"
        widthTextField?.stringValue = String(format: "%.0f", config.widthPercent * 100)
        widthSlider?.doubleValue = config.widthPercent * 100

        heightLabel?.stringValue = "高度 (%):"
        heightTextField?.stringValue = String(format: "%.0f", config.heightPercent * 100)
        heightSlider?.doubleValue = config.heightPercent * 100
    }

    // 清理设置窗口UI元素引用
    private func cleanupSettingUIElements() {
        // 移除滑块的目标-动作绑定
        xSlider?.target = nil
        ySlider?.target = nil
        widthSlider?.target = nil
        heightSlider?.target = nil
        menuBarCheckbox?.target = nil
        hotkeyPopup?.target = nil
        for checkbox in modifierCheckboxes {
            checkbox.target = nil
        }

        // 清空引用
        xLabel = nil
        xSlider = nil
        xTextField = nil
        yLabel = nil
        ySlider = nil
        yTextField = nil
        widthLabel = nil
        widthSlider = nil
        widthTextField = nil
        heightLabel = nil
        heightSlider = nil
        heightTextField = nil
        menuBarCheckbox = nil
        hotkeyLabel = nil
        hotkeyPopup = nil
        modifierCheckboxes = []
    }

    private func createSettingsWindow() {
        let window = NSWindow(
            contentRect: NSRect(x: 0, y: 0, width: 420, height: 420),
            styleMask: [.titled, .closable],
            backing: .buffered,
            defer: false
        )

        window.title = "WindowSnap 设置"
        window.center()

        let contentView = NSView(frame: NSRect(x: 0, y: 0, width: 420, height: 420))

        var yPosition: CGFloat = 370

        // 快捷键配置标题
        let hotkeyTitle = NSTextField(labelWithString: "快捷键设置:")
        hotkeyTitle.font = NSFont.boldSystemFont(ofSize: 13)
        hotkeyTitle.frame = NSRect(x: 20, y: yPosition, width: 150, height: 20)
        contentView.addSubview(hotkeyTitle)
        yPosition -= 30

        // 修饰键复选框
        let modifierLabels = ["Shift", "Control", "Option", "Command"]
        var xCheckbox: CGFloat = 30
        for (index, label) in modifierLabels.enumerated() {
            let checkbox = NSButton(checkboxWithTitle: label, target: self, action: #selector(hotkeyModifierChanged(_:)))
            checkbox.frame = NSRect(x: xCheckbox, y: yPosition, width: 90, height: 20)
            checkbox.tag = index
            // 设置初始状态
            let modifierMask = config.hotkeyModifiers
            let isOn: Bool
            switch index {
            case 0: isOn = (modifierMask & 0x20000) != 0
            case 1: isOn = (modifierMask & 0x40000) != 0
            case 2: isOn = (modifierMask & 0x80000) != 0
            case 3: isOn = (modifierMask & 0x100000) != 0
            default: isOn = false
            }
            checkbox.state = isOn ? .on : .off
            contentView.addSubview(checkbox)
            modifierCheckboxes.append(checkbox)
            xCheckbox += 85
        }
        yPosition -= 30

        // 键位选择下拉框
        hotkeyLabel = NSTextField(labelWithString: "按键:")
        hotkeyLabel?.frame = NSRect(x: 20, y: yPosition, width: 60, height: 20)
        contentView.addSubview(hotkeyLabel!)

        hotkeyPopup = NSPopUpButton(frame: NSRect(x: 80, y: yPosition, width: 100, height: 24), pullsDown: false)
        let keyItems = [
            ("Z", 6), ("X", 7), ("C", 8), ("V", 9),
            ("A", 0), ("S", 1), ("D", 2), ("F", 3),
            ("Q", 12), ("W", 13), ("E", 14), ("R", 15),
            ("1", 18), ("2", 19), ("3", 20), ("4", 21),
            ("Space", 49), ("Enter", 36), ("Escape", 53)
        ]
        for (name, code) in keyItems {
            hotkeyPopup?.addItem(withTitle: name)
            hotkeyPopup?.lastItem?.tag = code
        }
        hotkeyPopup?.target = self
        hotkeyPopup?.action = #selector(hotkeyKeyChanged(_:))
        contentView.addSubview(hotkeyPopup!)

        // 设置当前选中的键
        if let popup = hotkeyPopup, let menu = popup.menu {
            for (index, item) in menu.items.enumerated() {
                if item.tag == config.hotkeyKeyCode {
                    popup.selectItem(at: index)
                    break
                }
            }
        }

        // 显示当前快捷键
        let currentHotkeyLabel = NSTextField(labelWithString: "当前: \(getHotkeyDescription())")
        currentHotkeyLabel.font = NSFont.systemFont(ofSize: 11)
        currentHotkeyLabel.textColor = .secondaryLabelColor
        currentHotkeyLabel.frame = NSRect(x: 200, y: yPosition, width: 180, height: 20)
        currentHotkeyLabel.tag = 1001  // 用于更新
        contentView.addSubview(currentHotkeyLabel)
        yPosition -= 50

        // 位置和大小配置标题
        let positionTitle = NSTextField(labelWithString: "窗口位置和大小:")
        positionTitle.font = NSFont.boldSystemFont(ofSize: 13)
        positionTitle.frame = NSRect(x: 20, y: yPosition, width: 200, height: 20)
        contentView.addSubview(positionTitle)
        yPosition -= 30

        // X坐标
        xLabel = NSTextField(labelWithString: "横坐标 (%):")
        xLabel?.frame = NSRect(x: 20, y: yPosition, width: 90, height: 20)
        contentView.addSubview(xLabel!)

        xTextField = NSTextField(frame: NSRect(x: 115, y: yPosition, width: 50, height: 22))
        xTextField?.delegate = self
        xTextField?.tag = 1
        xTextField?.toolTip = "输入 0-100 的数值"
        contentView.addSubview(xTextField!)

        xSlider = NSSlider(value: config.xPercent * 100, minValue: 0, maxValue: 100, target: self, action: #selector(xSliderChanged(_:)))
        xSlider?.frame = NSRect(x: 175, y: yPosition, width: 220, height: 20)
        contentView.addSubview(xSlider!)
        yPosition -= 35

        // Y坐标
        yLabel = NSTextField(labelWithString: "纵坐标 (%):")
        yLabel?.frame = NSRect(x: 20, y: yPosition, width: 90, height: 20)
        contentView.addSubview(yLabel!)

        yTextField = NSTextField(frame: NSRect(x: 115, y: yPosition, width: 50, height: 22))
        yTextField?.delegate = self
        yTextField?.tag = 2
        yTextField?.toolTip = "输入 0-100 的数值"
        contentView.addSubview(yTextField!)

        ySlider = NSSlider(value: config.yPercent * 100, minValue: 0, maxValue: 100, target: self, action: #selector(ySliderChanged(_:)))
        ySlider?.frame = NSRect(x: 175, y: yPosition, width: 220, height: 20)
        contentView.addSubview(ySlider!)
        yPosition -= 35

        // 宽度
        widthLabel = NSTextField(labelWithString: "宽度 (%):")
        widthLabel?.frame = NSRect(x: 20, y: yPosition, width: 90, height: 20)
        contentView.addSubview(widthLabel!)

        widthTextField = NSTextField(frame: NSRect(x: 115, y: yPosition, width: 50, height: 22))
        widthTextField?.delegate = self
        widthTextField?.tag = 3
        widthTextField?.toolTip = "输入 10-100 的数值"
        contentView.addSubview(widthTextField!)

        widthSlider = NSSlider(value: config.widthPercent * 100, minValue: 10, maxValue: 100, target: self, action: #selector(widthSliderChanged(_:)))
        widthSlider?.frame = NSRect(x: 175, y: yPosition, width: 220, height: 20)
        contentView.addSubview(widthSlider!)
        yPosition -= 35

        // 高度
        heightLabel = NSTextField(labelWithString: "高度 (%):")
        heightLabel?.frame = NSRect(x: 20, y: yPosition, width: 90, height: 20)
        contentView.addSubview(heightLabel!)

        heightTextField = NSTextField(frame: NSRect(x: 115, y: yPosition, width: 50, height: 22))
        heightTextField?.delegate = self
        heightTextField?.tag = 4
        heightTextField?.toolTip = "输入 10-100 的数值"
        contentView.addSubview(heightTextField!)

        heightSlider = NSSlider(value: config.heightPercent * 100, minValue: 10, maxValue: 100, target: self, action: #selector(heightSliderChanged(_:)))
        heightSlider?.frame = NSRect(x: 175, y: yPosition, width: 220, height: 20)
        contentView.addSubview(heightSlider!)
        yPosition -= 50

        // 菜单栏图标选项
        menuBarCheckbox = NSButton(checkboxWithTitle: "显示菜单栏图标", target: self, action: #selector(menuBarCheckboxChanged(_:)))
        menuBarCheckbox?.frame = NSRect(x: 20, y: yPosition, width: 200, height: 20)
        menuBarCheckbox?.state = config.showMenuBarIcon ? .on : .off
        contentView.addSubview(menuBarCheckbox!)

        // 保存按钮
        let saveButton = NSButton(title: "保存", target: self, action: #selector(saveSettings))
        saveButton.frame = NSRect(x: 300, y: yPosition - 5, width: 100, height: 30)
        contentView.addSubview(saveButton)

        window.contentView = contentView
        settingsWindow = window

        // 设置窗口委托
        window.delegate = self

        // 确保标签文本与当前配置一致
        updateLabels()
    }

    @objc private func xSliderChanged(_ sender: NSSlider) {
        config.xPercent = max(0, min(1, sender.doubleValue / 100.0))
        updateLabels()
    }

    @objc private func ySliderChanged(_ sender: NSSlider) {
        config.yPercent = max(0, min(1, sender.doubleValue / 100.0))
        updateLabels()
    }

    @objc private func widthSliderChanged(_ sender: NSSlider) {
        config.widthPercent = max(0.1, min(1, sender.doubleValue / 100.0))
        updateLabels()
    }

    @objc private func heightSliderChanged(_ sender: NSSlider) {
        config.heightPercent = max(0.1, min(1, sender.doubleValue / 100.0))
        updateLabels()
    }

    @objc private func menuBarCheckboxChanged(_ sender: NSButton) {
        config.showMenuBarIcon = sender.state == .on
    }

    // 快捷键修饰键变化
    @objc private func hotkeyModifierChanged(_ sender: NSButton) {
        config.hotkeyKeyCode = currentHotkeyKeyCode
        config.hotkeyModifiers = currentHotkeyModifiers
        updateMenuTitle()
        updateCurrentHotkeyLabel()
    }

    // 快捷键按键变化
    @objc private func hotkeyKeyChanged(_ sender: NSPopUpButton) {
        config.hotkeyKeyCode = currentHotkeyKeyCode
        config.hotkeyModifiers = currentHotkeyModifiers
        updateMenuTitle()
        updateCurrentHotkeyLabel()
    }

    // 更新当前快捷键显示标签
    private func updateCurrentHotkeyLabel() {
        if let window = settingsWindow,
           let contentView = window.contentView {
            for subview in contentView.subviews {
                if subview.tag == 1001 {
                    if let label = subview as? NSTextField {
                        label.stringValue = "当前: \(getHotkeyDescription())"
                    }
                }
            }
        }
    }

    @objc private func saveSettings() {
        // 验证windowSnap实例存在
        guard let windowSnap = windowSnap else {
            os_log("错误：windowSnap实例为nil，无法更新配置", log: logger, type: .error)
            let alert = NSAlert()
            alert.messageText = "保存失败"
            alert.informativeText = "内部错误：窗口调整器未初始化。请重启应用。"
            alert.alertStyle = .critical
            alert.addButton(withTitle: "确定")
            alert.runModal()
            return
        }

        // 保存配置
        ConfigManager.shared.save(config)

        // 确保windowSnap使用最新配置
        windowSnap.updateConfig(config)
        hotkeyListener?.updateConfig(config)

        // 隐藏设置窗口
        settingsWindow?.orderOut(nil)

        // 清理UI元素引用
        cleanupSettingUIElements()
        self.settingsWindow = nil
    }
}

extension AppDelegate: NSWindowDelegate {
    func windowWillClose(_ notification: Notification) {
        // 确保通知对象是设置窗口
        guard let closingWindow = notification.object as? NSWindow,
              closingWindow == settingsWindow else {
            return
        }

        // 清理UI元素引用
        cleanupSettingUIElements()
        settingsWindow = nil
    }
}

extension AppDelegate: NSTextFieldDelegate {
    // 文本框值变化时同步到滑块和配置
    func controlTextDidChange(_ obj: Notification) {
        guard let textField = obj.object as? NSTextField else { return }

        let value = Double(textField.stringValue) ?? 0
        let tag = textField.tag

        switch tag {
        case 1:  // X坐标
            let clampedValue = max(0, min(100, value))
            config.xPercent = clampedValue / 100.0
            xSlider?.doubleValue = clampedValue
            xTextField?.stringValue = String(format: "%.0f", clampedValue)

        case 2:  // Y坐标
            let clampedValue = max(0, min(100, value))
            config.yPercent = clampedValue / 100.0
            ySlider?.doubleValue = clampedValue
            yTextField?.stringValue = String(format: "%.0f", clampedValue)

        case 3:  // 宽度
            let clampedValue = max(10, min(100, value))
            config.widthPercent = clampedValue / 100.0
            widthSlider?.doubleValue = clampedValue
            widthTextField?.stringValue = String(format: "%.0f", clampedValue)

        case 4:  // 高度
            let clampedValue = max(10, min(100, value))
            config.heightPercent = clampedValue / 100.0
            heightSlider?.doubleValue = clampedValue
            heightTextField?.stringValue = String(format: "%.0f", clampedValue)

        default:
            break
        }
    }
}

// MARK: - 主入口点

// 旧的主入口点（已弃用）
// let listener = HotkeyListener()
// listener.start()

// 新的主入口点
let app = NSApplication.shared
let delegate = AppDelegate()
app.delegate = delegate
app.run()
