import Foundation
import ApplicationServices
import CoreGraphics
import AppKit

class WindowManager {
    static let shared = WindowManager()

    private init() {}

    func setupAccessibilityPermission() {
        let options: NSDictionary = [kAXTrustedCheckOptionPrompt.takeUnretainedValue() as String: true]
        let accessEnabled = AXIsProcessTrustedWithOptions(options)
        if !accessEnabled {
            print("Warning: Accessibility permission not granted. Window centering may not work.")
        }
    }

    func centerFrontmostWindow() {
        guard let targetWindow = getFrontmostWindow() else {
            print("No active window found")
            return
        }

        let screen = getCurrentScreen(for: targetWindow)
        let settings = SettingsManager.shared.settings

        centerWindow(targetWindow, on: screen, scaleX: settings.scaleX, scaleY: settings.scaleY)
    }

    private func getFrontmostWindow() -> CGWindowID? {
        let options: CGWindowListOption = [.optionOnScreenOnly, .excludeDesktopElements]
        let windowListInfo = CGWindowListCopyWindowInfo(options, kCGNullWindowID) as? [[String: Any]]

        guard let windows = windowListInfo else { return nil }

        for window in windows {
            if let windowLayer = window[kCGWindowLayer as String] as? Int,
               windowLayer == 0,
               let windowID = window[kCGWindowNumber as String] as? CGWindowID,
               let ownerName = window[kCGWindowOwnerName as String] as? String {
                // Skip our own app's windows
                if ownerName == "WindowSnap" { continue }
                return windowID
            }
        }

        return nil
    }

    private func getCurrentScreen(for windowID: CGWindowID) -> NSScreen? {
        let options: CGWindowListOption = [.optionOnScreenOnly]
        let windowListInfo = CGWindowListCopyWindowInfo(options, windowID) as? [[String: Any]]

        guard let windowInfo = windowListInfo?.first,
              let bounds = windowInfo[kCGWindowBounds as String] as? [String: CGFloat],
              let x = bounds["X"], let y = bounds["Y"],
              let width = bounds["Width"], let height = bounds["Height"] else {
            // Fallback to screen with mouse
            return getScreenWithMouse()
        }

        let windowFrame = CGRect(x: x, y: y, width: width, height: height)

        for screen in NSScreen.screens {
            if screen.frame.intersects(windowFrame) {
                return screen
            }
        }

        return getScreenWithMouse()
    }

    private func getScreenWithMouse() -> NSScreen? {
        let mouseLocation = NSEvent.mouseLocation
        for screen in NSScreen.screens {
            if screen.frame.contains(mouseLocation) {
                return screen
            }
        }
        return NSScreen.screens.first
    }

    private func centerWindow(_ windowID: CGWindowID, on screen: NSScreen?, scaleX: Double, scaleY: Double) {
        guard let screen = screen else { return }

        let screenFrame = screen.frame
        let targetWidth = screenFrame.width * scaleX
        let targetHeight = screenFrame.height * scaleY

        let newX = screenFrame.origin.x + (screenFrame.width - targetWidth) / 2
        let newY = screenFrame.origin.y + (screenFrame.height - targetHeight) / 2

        // Use AXUIElement for window manipulation
        let runningApp = NSRunningApplication.current
        let pid = runningApp.processIdentifier
        let axApp = AXUIElementCreateApplication(pid)

        var windows: CFArray?
        guard AXUIElementCopyAttributeValues(axApp, kAXWindowsAttribute as CFString, 0, 10, &windows) == .success,
              let winList = windows else { return }

        let count = CFArrayGetCount(winList)
        for i in 0..<count {
            let axWin = unsafeBitCast(CFArrayGetValueAtIndex(winList, i), to: AXUIElement.self)

            var axPosition: CFTypeRef?
            if AXUIElementCopyAttributeValue(axWin, kAXPositionAttribute as CFString, &axPosition) == .success {
                var point = CGPoint(x: newX, y: newY)
                let newPosition = AXValueCreate(.cgPoint, &point)!
                AXUIElementSetAttributeValue(axWin, kAXPositionAttribute as CFString, newPosition)

                var size = CGSize(width: targetWidth, height: targetHeight)
                let newSize = AXValueCreate(.cgSize, &size)!
                AXUIElementSetAttributeValue(axWin, kAXSizeAttribute as CFString, newSize)
                break
            }
        }
    }
}
